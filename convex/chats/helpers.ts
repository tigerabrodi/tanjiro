import { GoogleGenAI, Modality } from '@google/genai'
import { ConvexError } from 'convex/values'

import { api } from '../_generated/api'
import type { Id } from '../_generated/dataModel'
import type { ActionCtx } from '../_generated/server'
import { handlePromise } from '../lib/utils'

async function getGeminiApiKey(ctx: ActionCtx) {
  const apiKey = await ctx.runAction(api.users.actions.getGeminiApiKey, {})
  if (!apiKey) {
    throw new ConvexError(
      'Gemini API key not found. Please add your API key in settings.'
    )
  }
  return apiKey
}

export async function generateImageWithGemini({
  ctx,
  prompt,
}: {
  ctx: ActionCtx
  prompt: string
}) {
  const [getGeminiApiKeyError, apiKey] = await handlePromise(
    getGeminiApiKey(ctx)
  )
  if (getGeminiApiKeyError) {
    throw getGeminiApiKeyError
  }

  const ai = new GoogleGenAI({ apiKey })

  const response = await ai.models.generateContent({
    model: 'gemini-2.0-flash-preview-image-generation',
    contents: prompt,
    config: {
      responseModalities: [Modality.TEXT, Modality.IMAGE],
    },
  })

  let aiResponseText = ''
  let imageData = null

  for (const part of response.candidates?.[0]?.content?.parts ?? []) {
    if (part.text) {
      aiResponseText += part.text
    } else if (part.inlineData) {
      imageData = part.inlineData.data
    }
  }

  if (!imageData) {
    throw new ConvexError('No image generated by Gemini')
  }

  // Store image in Convex
  const buffer = Buffer.from(imageData, 'base64')
  const blob = new Blob([buffer], { type: 'image/png' })
  const storageId = await ctx.storage.store(blob)

  return {
    outputImageId: storageId,
    aiResponseText: aiResponseText.trim(),
  }
}

export async function editImageWithGemini({
  ctx,
  inputImageId,
  prompt,
}: {
  ctx: ActionCtx
  inputImageId: string
  prompt: string
}) {
  const [getGeminiApiKeyError, apiKey] = await handlePromise(
    getGeminiApiKey(ctx)
  )
  if (getGeminiApiKeyError) {
    throw getGeminiApiKeyError
  }

  const ai = new GoogleGenAI({ apiKey })

  // Get input image
  const inputImageBlob = await ctx.storage.get(inputImageId)
  if (!inputImageBlob) {
    throw new ConvexError('Input image not found')
  }

  // Convert to base64
  const buffer = await inputImageBlob.arrayBuffer()
  const base64Image = Buffer.from(buffer).toString('base64')

  // Prepare content for Gemini
  const contents = [
    { text: prompt },
    {
      inlineData: {
        mimeType: inputImageBlob.type || 'image/png',
        data: base64Image,
      },
    },
  ]

  const response = await ai.models.generateContent({
    model: 'gemini-2.0-flash-preview-image-generation',
    contents: contents,
    config: {
      responseModalities: [Modality.TEXT, Modality.IMAGE],
    },
  })

  let aiResponseText = ''
  let imageData = null

  for (const part of response.candidates?.[0]?.content?.parts ?? []) {
    if (part.text) {
      aiResponseText += part.text
    } else if (part.inlineData) {
      imageData = part.inlineData.data
    }
  }

  if (!imageData) {
    throw new ConvexError('No image generated by Gemini')
  }

  // Store edited image in Convex
  const outputBuffer = Buffer.from(imageData, 'base64')
  const outputBlob = new Blob([outputBuffer], { type: 'image/png' })
  const outputStorageId = await ctx.storage.store(outputBlob)

  return {
    outputImageId: outputStorageId,
    aiResponseText: aiResponseText || 'Image edited successfully',
  }
}

export async function createChatWithEdits({
  ctx,
  edits,
  currentEditIndex,
}: {
  ctx: ActionCtx
  edits: Array<{
    userPrompt: string
    inputImageId: Id<'_storage'>
    outputImageId: Id<'_storage'>
    aiResponseText: string
  }>
  currentEditIndex: number
}) {
  const [createChatError, chatId] = await handlePromise(
    ctx.runMutation(api.chats.mutations.createChat, {
      title: 'Untitled',
      currentEditIndex,
    })
  )

  if (createChatError) {
    throw new ConvexError('Failed to create chat')
  }

  // Create all edits and collect IDs
  const editIds: Array<Id<'edits'>> = []
  for (const edit of edits) {
    // eslint-disable-next-line no-await-in-loop
    const editId = await ctx.runMutation(api.edits.mutations.insertEdit, {
      chatId,
      userPrompt: edit.userPrompt,
      inputImageId: edit.inputImageId,
      outputImageId: edit.outputImageId,
      aiResponseText: edit.aiResponseText,
    })
    editIds.push(editId)
  }

  // Update chat with edit history
  await ctx.runMutation(api.chats.mutations.setEditHistory, {
    chatId,
    editHistory: editIds,
  })

  return chatId
}
